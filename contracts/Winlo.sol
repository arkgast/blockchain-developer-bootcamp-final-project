//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.9;

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "hardhat/console.sol";

/// @title A lottery game.
/// @notice Main contract that contains functions used by fronted application.
/// @dev Implementation is basic can be improved with already tested libraries.
contract Winlo is Ownable, Pausable, VRFConsumerBase {
  /// @notice Entry fee cost.
  /// @dev Fixed value, it could be ideal to make this dynamic.
  uint256 public ticketPrice = 0.001 ether;

  // @notice List of current players.
  // @dev List of player addresses.
  address payable[] public players;
  /// @notice List of winners.
  /// @dev List of winners addresses.
  address[] public winners;
  /// @notice Last lottery winner.
  address public lastWinner;

  /// @dev Public key against which randomness is generated
  bytes32 private keyHash;
  /// @dev chainlink oracle fee
  uint256 private fee;
  /// @notice Random number generated
  /// @dev This value is generated by chainlink oracle
  uint256 public randomResult;

  /// @notice Event emitted when a new player is registered.
  /// @param _player Player address
  /// @dev The event is emitted with the address of the new player.
  event NewPlayer(address indexed _player);

  /// @notice Event emitted when there is a refund.
  /// @param _player Player address.
  /// @param _refundedAmount Amount that was refunded.
  event Refund(address indexed _player, uint256 indexed _refundedAmount);

  /// @notice Event emitted when a winner is selected.
  /// @param _winner Winner address
  /// @param _prize Amount winner earned.
  event Winner(address indexed _winner, uint256 indexed _prize);

  constructor(address _vrfCoordinatorAddress, address _linkTokenAddress, bytes32 _keyHash)
    VRFConsumerBase(_vrfCoordinatorAddress, _linkTokenAddress)
  {
    keyHash = _keyHash;
    fee = 0.1 * 10 ** 18; // 0.1 LINK;
  }

  modifier costToEnter() {
    require(msg.value >= ticketPrice, "You should sent 0.001 eth");
    _;
  }

  /// @notice Adds a player to the list of players.
  /// @dev Checks the amount is correct and that it is on a valid state.
  function buyTicket() external payable whenNotPaused costToEnter {
    _refund();

    players.push(payable(msg.sender));
    emit NewPlayer(msg.sender);
  }

  /// @notice Refund user in case it sends more than it was required.
  function _refund() private {
    if (msg.value > ticketPrice) {
      uint256 amountToRefund = msg.value - ticketPrice;
      (bool success, ) = payable(msg.sender).call{ value: amountToRefund }("");

      require(success, "Refund failed");
      emit Refund(msg.sender, amountToRefund);
    }
  }

  /// @notice Selects a random winner.
  function selectWinner() external onlyOwner whenNotPaused returns (bytes32) {
    require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");

    _pause();

    return requestRandomness(keyHash, fee);
  }

  function fulfillRandomness(bytes32, uint256 _randomness) internal override whenPaused {
    randomResult = _randomness % players.length;
    address winner = players[randomResult];
    lastWinner = winner;
    winners.push(winner);
    delete players;

    uint256 prize = address(this).balance;
    (bool success, ) = payable(winner).call{ value: prize }("");
    require(success, "Adwarding failed");

    _unpause();
    emit Winner(winner, prize);
  }

  /// @notice Change ticket price
  function changeTicketPrice(uint256 _ticketPrice) external onlyOwner whenPaused {
    ticketPrice = _ticketPrice;
  }

  /// @notice Get list of current players.
  /// @return list of players
  function getPlayers() external view returns(address payable[] memory) {
    return players;
  }

  /// @notice Get list of previous winners.
  /// @return list of winners.
  function getWinners() external view returns (address[] memory) {
    return winners;
  }

  /// @notice Pause contract
  function pause() external onlyOwner whenNotPaused {
    _pause();
  }

  /// @notice Unpause contract
  function unpause() external onlyOwner whenPaused {
    _unpause();
  }
}
